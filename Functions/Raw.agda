{-# OPTIONS --safe --without-K #-}

open import Level

module Functions.Raw (‚Ñì : Level) where

import Function as F
open import Data.Product as √ó using (_,_; proj‚ÇÅ; proj‚ÇÇ; <_,_>)
open import Data.Sum using (inj‚ÇÅ; inj‚ÇÇ; [_,_])
open import Data.Empty.Polymorphic using (‚ä•-elim)
import Data.Bool as B

open import Categorical.Raw
open import Categorical.Equiv

open import Functions.Type ‚Ñì public

module ‚Üí-raw-instances where

  instance

    category : Category Function
    category = record { id = F.id ; _‚àò_ = F._‚àò‚Ä≤_ }

    cocartesian : Cocartesian Function
    cocartesian = record { void = ‚ä•-elim ; _‚ñø_ = [_,_] ; inl = inj‚ÇÅ ; inr = inj‚ÇÇ }

    cartesian : Cartesian Function
    cartesian = record { _‚ñµ_ = <_,_> ; exl = proj‚ÇÅ ; exr = proj‚ÇÇ }

    -- indexedCartesian : ‚àÄ {I : Set ‚Ñì} ‚Üí IndexedCartesian I Function
    -- indexedCartesian = record
    --   { ‚ñ≥  = Œª fs x i ‚Üí fs i x
    --   ; ex = Œª i xs ‚Üí xs i
    --   }

    cartesianClosed : CartesianClosed Function
    cartesianClosed = record { curry = √ó.curry ; apply = √ó.uncurry id }

    open import HasAlgebra

    semigroup : ‚àÄ {A : Set ‚Ñì} ‚¶É _ : HasRawSemigroup A ‚¶Ñ ‚Üí Semigroup Function
    semigroup = record { ‚ü®‚àô‚ü© = uncurry _‚àô_ }

    monoid : ‚àÄ {A : Set ‚Ñì} ‚¶É _ : HasRawSemigroup A ‚¶Ñ ‚¶É _ : HasRawMonoid A ‚¶Ñ ‚Üí
      Monoid Function
    monoid = record { ‚ü®Œπ‚ü© = Œª { tt ‚Üí Œπ } }

    logic : Logic Function
    logic = record
              { false = Œª tt ‚Üí ùïó
              ; true  = Œª tt ‚Üí ùï•
              ; not   = lift‚ÇÅ B.not
              ; ‚àß     = uncurry (lift‚ÇÇ B._‚àß_)
              ; ‚à®     = uncurry (lift‚ÇÇ B._‚à®_)
              ; xor   = uncurry (lift‚ÇÇ B._xor_)
              ; cond  = Œª (lift c , e , t) ‚Üí B.if c then t else e
              }

    open import Relation.Binary.PropositionalEquality as ‚â° using (_‚â°_; _‚âó_)

    -- TODO: move to Relation.Binary.PropositionalEquality.Properties as a PR
    equivalent : Equivalent ‚Ñì Function
    equivalent = record
      { _‚âà_ = _‚âó_
      ; equiv = record
          { refl  = Œª _ ‚Üí ‚â°.refl
          ; sym   = Œª f‚àºg x ‚Üí ‚â°.sym (f‚àºg x)
          ; trans = Œª f‚àºg g‚àºh x ‚Üí ‚â°.trans (f‚àºg x) (g‚àºh x)
          }
      }
